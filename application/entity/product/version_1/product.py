# entity/product/version_1/product.py

"""
Product Entity for Pet Store Performance Analysis System

Represents a product from the Pet Store API with additional performance metrics
for sales analysis and inventory management as specified in functional requirements.
"""

from datetime import datetime, timezone
from typing import Any, ClassVar, Dict, List, Optional

from pydantic import ConfigDict, Field, field_validator, model_validator

from common.entity.cyoda_entity import CyodaEntity


class Product(CyodaEntity):
    """
    Product entity represents a pet from the Pet Store API with additional
    performance metrics for sales analysis and reporting.

    Inherits from CyodaEntity to get common fields like entity_id, state, etc.
    The state field manages workflow states: initial_state -> extracted -> analyzed -> reported
    """

    # Entity constants
    ENTITY_NAME: ClassVar[str] = "Product"
    ENTITY_VERSION: ClassVar[int] = 1

    # Core Pet Store API fields (based on Pet schema)
    pet_id: Optional[int] = Field(
        default=None,
        alias="petId",
        description="Pet ID from the Pet Store API"
    )
    name: str = Field(..., description="Name of the pet/product")
    category_id: Optional[int] = Field(
        default=None,
        alias="categoryId", 
        description="Category ID from Pet Store API"
    )
    category_name: Optional[str] = Field(
        default=None,
        alias="categoryName",
        description="Category name (e.g., Dogs, Cats)"
    )
    status: str = Field(
        default="available",
        description="Pet status in the store (available, pending, sold)"
    )
    photo_urls: Optional[List[str]] = Field(
        default_factory=list,
        alias="photoUrls",
        description="List of photo URLs for the pet"
    )
    tags: Optional[List[str]] = Field(
        default_factory=list,
        description="List of tags associated with the pet"
    )

    # Performance metrics fields (for analysis)
    price: Optional[float] = Field(
        default=None,
        description="Product price for performance analysis"
    )
    sales_volume: Optional[int] = Field(
        default=0,
        alias="salesVolume",
        description="Number of units sold"
    )
    revenue: Optional[float] = Field(
        default=0.0,
        description="Total revenue generated by this product"
    )
    inventory_count: Optional[int] = Field(
        default=0,
        alias="inventoryCount",
        description="Current inventory count"
    )
    last_sale_date: Optional[str] = Field(
        default=None,
        alias="lastSaleDate",
        description="Date of last sale (ISO 8601 format)"
    )

    # Timestamps
    extracted_at: Optional[str] = Field(
        default=None,
        alias="extractedAt",
        description="Timestamp when data was extracted from Pet Store API"
    )
    analyzed_at: Optional[str] = Field(
        default=None,
        alias="analyzedAt",
        description="Timestamp when performance analysis was completed"
    )

    # Analysis results
    performance_score: Optional[float] = Field(
        default=None,
        alias="performanceScore",
        description="Calculated performance score (0-100)"
    )
    trend_indicator: Optional[str] = Field(
        default=None,
        alias="trendIndicator",
        description="Trend indicator: RISING, STABLE, DECLINING"
    )
    restock_needed: Optional[bool] = Field(
        default=False,
        alias="restockNeeded",
        description="Flag indicating if restocking is needed"
    )

    # Validation constants
    ALLOWED_STATUSES: ClassVar[List[str]] = ["available", "pending", "sold"]
    ALLOWED_TRENDS: ClassVar[List[str]] = ["RISING", "STABLE", "DECLINING"]

    @field_validator("name")
    @classmethod
    def validate_name(cls, v: str) -> str:
        """Validate name field"""
        if not v or len(v.strip()) == 0:
            raise ValueError("Product name must be non-empty")
        if len(v) > 200:
            raise ValueError("Product name must be at most 200 characters long")
        return v.strip()

    @field_validator("status")
    @classmethod
    def validate_status(cls, v: str) -> str:
        """Validate status field"""
        if v not in cls.ALLOWED_STATUSES:
            raise ValueError(f"Status must be one of: {cls.ALLOWED_STATUSES}")
        return v

    @field_validator("trend_indicator")
    @classmethod
    def validate_trend_indicator(cls, v: Optional[str]) -> Optional[str]:
        """Validate trend indicator field"""
        if v is not None and v not in cls.ALLOWED_TRENDS:
            raise ValueError(f"Trend indicator must be one of: {cls.ALLOWED_TRENDS}")
        return v

    @field_validator("performance_score")
    @classmethod
    def validate_performance_score(cls, v: Optional[float]) -> Optional[float]:
        """Validate performance score is between 0 and 100"""
        if v is not None and (v < 0 or v > 100):
            raise ValueError("Performance score must be between 0 and 100")
        return v

    @model_validator(mode="after")
    def validate_business_logic(self) -> "Product":
        """Validate business logic rules"""
        # If sales_volume > 0, revenue should also be > 0
        if self.sales_volume and self.sales_volume > 0:
            if not self.revenue or self.revenue <= 0:
                raise ValueError("Revenue must be positive when sales volume is positive")

        # If inventory_count is 0 and status is available, suggest restocking
        if self.inventory_count == 0 and self.status == "available":
            self.restock_needed = True

        return self

    def update_extraction_timestamp(self) -> None:
        """Update the extracted_at timestamp to current time"""
        self.extracted_at = datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")

    def update_analysis_timestamp(self) -> None:
        """Update the analyzed_at timestamp to current time"""
        self.analyzed_at = datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")

    def calculate_performance_score(self) -> float:
        """Calculate performance score based on sales and inventory metrics"""
        if not self.sales_volume or not self.revenue:
            return 0.0

        # Simple performance calculation
        base_score = min(50.0, (self.sales_volume / 10) * 10)  # Up to 50 points for volume
        revenue_score = min(30.0, (self.revenue / 1000) * 10)  # Up to 30 points for revenue
        inventory_score = 20.0 if self.inventory_count and self.inventory_count > 0 else 0.0

        total_score = base_score + revenue_score + inventory_score
        self.performance_score = min(100.0, total_score)
        return self.performance_score

    def determine_trend(self) -> str:
        """Determine trend based on performance metrics"""
        if not self.performance_score:
            return "STABLE"

        if self.performance_score >= 70:
            self.trend_indicator = "RISING"
        elif self.performance_score <= 30:
            self.trend_indicator = "DECLINING"
        else:
            self.trend_indicator = "STABLE"

        return self.trend_indicator

    def is_high_performer(self) -> bool:
        """Check if product is a high performer"""
        return self.performance_score is not None and self.performance_score >= 70

    def is_underperformer(self) -> bool:
        """Check if product is underperforming"""
        return self.performance_score is not None and self.performance_score <= 30

    def needs_attention(self) -> bool:
        """Check if product needs attention (low inventory or poor performance)"""
        return self.restock_needed or self.is_underperformer()

    def to_api_response(self) -> Dict[str, Any]:
        """Convert to API response format"""
        data = self.model_dump(by_alias=True)
        data["state"] = self.state
        return data

    model_config = ConfigDict(
        populate_by_name=True,
        use_enum_values=True,
        validate_assignment=True,
        extra="allow",
    )
