# entity/product/version_1/product.py

"""
Product Entity for Pet Store Performance Analysis System

Represents a product from the Pet Store API with performance metrics
and analysis data as specified in functional requirements.
"""

from datetime import datetime, timezone
from typing import Any, ClassVar, Dict, List, Optional

from pydantic import ConfigDict, Field, field_validator, model_validator

from common.entity.cyoda_entity import CyodaEntity


class Product(CyodaEntity):
    """
    Product represents a pet store product with performance metrics
    and analysis capabilities for the automated reporting system.

    Inherits from CyodaEntity to get common fields like entity_id, state, etc.
    The state field manages workflow states: initial_state -> data_extracted -> analyzed -> completed
    """

    # Entity constants
    ENTITY_NAME: ClassVar[str] = "Product"
    ENTITY_VERSION: ClassVar[int] = 1

    # Core product fields from Pet Store API
    name: str = Field(..., description="Product name from Pet Store API")
    category: str = Field(..., description="Product category classification")
    pet_store_id: Optional[str] = Field(
        default=None,
        alias="petStoreId",
        description="Original product ID from Pet Store API"
    )
    
    # Performance metrics fields
    sales_volume: Optional[int] = Field(
        default=0,
        alias="salesVolume",
        description="Total units sold"
    )
    revenue: Optional[float] = Field(
        default=0.0,
        description="Total revenue generated by this product"
    )
    inventory_level: Optional[int] = Field(
        default=0,
        alias="inventoryLevel",
        description="Current stock level"
    )
    
    # Analysis fields
    stock_status: Optional[str] = Field(
        default="UNKNOWN",
        alias="stockStatus",
        description="Stock status: IN_STOCK, LOW_STOCK, OUT_OF_STOCK, RESTOCK_NEEDED"
    )
    performance_score: Optional[float] = Field(
        default=0.0,
        alias="performanceScore",
        description="Calculated performance score (0-100)"
    )
    trend_analysis: Optional[Dict[str, Any]] = Field(
        default=None,
        alias="trendAnalysis",
        description="Trend analysis data populated during processing"
    )
    
    # Timestamps
    data_extracted_at: Optional[str] = Field(
        default=None,
        alias="dataExtractedAt",
        description="Timestamp when data was extracted from Pet Store API"
    )
    analyzed_at: Optional[str] = Field(
        default=None,
        alias="analyzedAt",
        description="Timestamp when performance analysis was completed"
    )

    # Validation constants
    ALLOWED_CATEGORIES: ClassVar[List[str]] = [
        "DOGS",
        "CATS", 
        "BIRDS",
        "FISH",
        "REPTILES",
        "SMALL_PETS",
        "ACCESSORIES",
        "FOOD",
        "TOYS",
        "HEALTH"
    ]
    
    ALLOWED_STOCK_STATUS: ClassVar[List[str]] = [
        "IN_STOCK",
        "LOW_STOCK", 
        "OUT_OF_STOCK",
        "RESTOCK_NEEDED",
        "UNKNOWN"
    ]

    @field_validator("name")
    @classmethod
    def validate_name(cls, v: str) -> str:
        """Validate product name field"""
        if not v or len(v.strip()) == 0:
            raise ValueError("Product name must be non-empty")
        if len(v) < 2:
            raise ValueError("Product name must be at least 2 characters long")
        if len(v) > 200:
            raise ValueError("Product name must be at most 200 characters long")
        return v.strip()

    @field_validator("category")
    @classmethod
    def validate_category(cls, v: str) -> str:
        """Validate category field"""
        if v not in cls.ALLOWED_CATEGORIES:
            raise ValueError(f"Category must be one of: {cls.ALLOWED_CATEGORIES}")
        return v

    @field_validator("stock_status")
    @classmethod
    def validate_stock_status(cls, v: Optional[str]) -> Optional[str]:
        """Validate stock status field"""
        if v is not None and v not in cls.ALLOWED_STOCK_STATUS:
            raise ValueError(f"Stock status must be one of: {cls.ALLOWED_STOCK_STATUS}")
        return v

    @field_validator("sales_volume", "inventory_level")
    @classmethod
    def validate_non_negative_int(cls, v: Optional[int]) -> Optional[int]:
        """Validate non-negative integer fields"""
        if v is not None and v < 0:
            raise ValueError("Value must be non-negative")
        return v

    @field_validator("revenue", "performance_score")
    @classmethod
    def validate_non_negative_float(cls, v: Optional[float]) -> Optional[float]:
        """Validate non-negative float fields"""
        if v is not None and v < 0:
            raise ValueError("Value must be non-negative")
        return v

    @field_validator("performance_score")
    @classmethod
    def validate_performance_score_range(cls, v: Optional[float]) -> Optional[float]:
        """Validate performance score is within 0-100 range"""
        if v is not None and (v < 0 or v > 100):
            raise ValueError("Performance score must be between 0 and 100")
        return v

    @model_validator(mode="after")
    def validate_business_logic(self) -> "Product":
        """Validate business logic rules"""
        # Validate stock status consistency with inventory level
        if self.inventory_level is not None and self.stock_status:
            if self.inventory_level == 0 and self.stock_status not in ["OUT_OF_STOCK", "UNKNOWN"]:
                raise ValueError("Products with zero inventory should have OUT_OF_STOCK status")
            elif self.inventory_level > 0 and self.stock_status == "OUT_OF_STOCK":
                raise ValueError("Products with inventory cannot have OUT_OF_STOCK status")

        return self

    def update_timestamp(self) -> None:
        """Update the updated_at timestamp to current time"""
        self.updated_at = datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")

    def set_data_extracted(self) -> None:
        """Mark data as extracted and update timestamp"""
        self.data_extracted_at = datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
        self.update_timestamp()

    def set_analyzed(self, performance_score: float, trend_analysis: Dict[str, Any]) -> None:
        """Mark product as analyzed with results"""
        self.performance_score = performance_score
        self.trend_analysis = trend_analysis
        self.analyzed_at = datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
        self.update_timestamp()

    def calculate_stock_status(self) -> str:
        """Calculate stock status based on inventory level"""
        if self.inventory_level is None:
            return "UNKNOWN"
        elif self.inventory_level == 0:
            return "OUT_OF_STOCK"
        elif self.inventory_level <= 5:  # Low stock threshold
            return "LOW_STOCK"
        elif self.inventory_level <= 10:  # Restock threshold
            return "RESTOCK_NEEDED"
        else:
            return "IN_STOCK"

    def is_high_performer(self) -> bool:
        """Check if product is a high performer (score >= 70)"""
        return self.performance_score is not None and self.performance_score >= 70

    def is_low_performer(self) -> bool:
        """Check if product is a low performer (score <= 30)"""
        return self.performance_score is not None and self.performance_score <= 30

    def needs_restocking(self) -> bool:
        """Check if product needs restocking"""
        return self.stock_status in ["LOW_STOCK", "OUT_OF_STOCK", "RESTOCK_NEEDED"]

    def to_api_response(self) -> Dict[str, Any]:
        """Convert to API response format"""
        data = self.model_dump(by_alias=True)
        data["state"] = self.state
        return data

    model_config = ConfigDict(
        populate_by_name=True,
        use_enum_values=True,
        validate_assignment=True,
        extra="allow",
    )
