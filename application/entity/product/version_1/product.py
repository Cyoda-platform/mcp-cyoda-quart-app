# entity/product/version_1/product.py

"""
Product Entity for Product Performance Analysis and Reporting System

Represents product data retrieved from the Pet Store API for performance analysis.
Stores product information including sales metrics, inventory levels, and performance indicators.
"""

from datetime import datetime, timezone
from typing import Any, ClassVar, Dict, Optional

from pydantic import ConfigDict, Field, field_validator

from common.entity.cyoda_entity import CyodaEntity


class Product(CyodaEntity):
    """
    Product entity represents product data from Pet Store API.

    Stores product information for performance analysis including:
    - Basic product details (name, category, status)
    - Sales metrics (price, sales volume, revenue)
    - Inventory information (stock levels, availability)
    - Performance indicators (calculated during analysis)
    """

    # Entity constants
    ENTITY_NAME: ClassVar[str] = "Product"
    ENTITY_VERSION: ClassVar[int] = 1

    # Basic product information from Pet Store API
    name: str = Field(..., description="Product name from Pet Store API")
    category: str = Field(..., description="Product category classification")
    status: str = Field(..., description="Product status (available, pending, sold)")

    # Pricing and sales information
    price: Optional[float] = Field(default=None, description="Product price in USD")
    sales_volume: Optional[int] = Field(
        default=None, alias="salesVolume", description="Number of units sold"
    )
    revenue: Optional[float] = Field(
        default=None, description="Total revenue generated by this product"
    )

    # Inventory information
    stock_level: Optional[int] = Field(
        default=None, alias="stockLevel", description="Current inventory stock level"
    )
    reorder_point: Optional[int] = Field(
        default=None,
        alias="reorderPoint",
        description="Inventory level that triggers reorder",
    )

    # Performance metrics (calculated during analysis)
    performance_score: Optional[float] = Field(
        default=None,
        alias="performanceScore",
        description="Calculated performance score (0-100)",
    )
    inventory_turnover_rate: Optional[float] = Field(
        default=None,
        alias="inventoryTurnoverRate",
        description="Inventory turnover rate calculation",
    )

    # Timestamps
    created_at: Optional[str] = Field(
        default_factory=lambda: datetime.now(timezone.utc)
        .isoformat()
        .replace("+00:00", "Z"),
        alias="createdAt",
        description="Timestamp when the product was created (ISO 8601 format)",
    )
    updated_at: Optional[str] = Field(
        default=None,
        alias="updatedAt",
        description="Timestamp when the product was last updated (ISO 8601 format)",
    )
    last_analyzed_at: Optional[str] = Field(
        default=None,
        alias="lastAnalyzedAt",
        description="Timestamp when performance analysis was last run",
    )

    # API source information
    api_id: Optional[str] = Field(
        default=None, alias="apiId", description="Original ID from Pet Store API"
    )
    api_source: str = Field(
        default="petstore", alias="apiSource", description="Source API identifier"
    )

    # Validation constants
    ALLOWED_STATUSES: ClassVar[list[str]] = ["available", "pending", "sold"]
    ALLOWED_CATEGORIES: ClassVar[list[str]] = [
        "Dogs",
        "Cats",
        "Fish",
        "Birds",
        "Reptiles",
        "Small Pets",
    ]

    @field_validator("name")
    @classmethod
    def validate_name(cls, v: str) -> str:
        """Validate product name"""
        if not v or len(v.strip()) == 0:
            raise ValueError("Product name must be non-empty")
        if len(v) > 200:
            raise ValueError("Product name must be at most 200 characters")
        return v.strip()

    @field_validator("status")
    @classmethod
    def validate_status(cls, v: str) -> str:
        """Validate product status"""
        if v not in cls.ALLOWED_STATUSES:
            raise ValueError(f"Status must be one of: {cls.ALLOWED_STATUSES}")
        return v

    @field_validator("price")
    @classmethod
    def validate_price(cls, v: Optional[float]) -> Optional[float]:
        """Validate product price"""
        if v is not None and v < 0:
            raise ValueError("Price must be non-negative")
        return v

    @field_validator("sales_volume")
    @classmethod
    def validate_sales_volume(cls, v: Optional[int]) -> Optional[int]:
        """Validate sales volume"""
        if v is not None and v < 0:
            raise ValueError("Sales volume must be non-negative")
        return v

    @field_validator("stock_level")
    @classmethod
    def validate_stock_level(cls, v: Optional[int]) -> Optional[int]:
        """Validate stock level"""
        if v is not None and v < 0:
            raise ValueError("Stock level must be non-negative")
        return v

    def update_timestamp(self) -> None:
        """Update the updated_at timestamp to current time"""
        self.updated_at = datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")

    def set_performance_metrics(
        self, performance_score: float, turnover_rate: float
    ) -> None:
        """Set performance metrics and update timestamps"""
        self.performance_score = performance_score
        self.inventory_turnover_rate = turnover_rate
        self.last_analyzed_at = (
            datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
        )
        self.update_timestamp()

    def calculate_revenue(self) -> float:
        """Calculate revenue from price and sales volume"""
        if self.price is not None and self.sales_volume is not None:
            self.revenue = self.price * self.sales_volume
            return self.revenue
        return 0.0

    def is_low_stock(self) -> bool:
        """Check if product is low on stock"""
        if self.stock_level is not None and self.reorder_point is not None:
            return self.stock_level <= self.reorder_point
        return False

    def is_high_performer(self) -> bool:
        """Check if product is a high performer (score > 70)"""
        return self.performance_score is not None and self.performance_score > 70

    def to_api_response(self) -> Dict[str, Any]:
        """Convert to API response format"""
        data = self.model_dump(by_alias=True)
        data["state"] = self.state
        return data

    model_config = ConfigDict(
        populate_by_name=True,
        use_enum_values=True,
        validate_assignment=True,
        extra="allow",
    )
